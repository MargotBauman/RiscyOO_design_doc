\documentclass[12pt]{article}
% my packages
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{verbatim}
\usepackage{color}
\usepackage{boxedminipage}
\usepackage{slashbox}
\usepackage{enumitem}
\usepackage[caption=false]{subfig}
\usepackage{url}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\definecolor{commentcolor}{rgb}{0,0.6,0}
\definecolor{keywordcolor}{rgb}{0,0,0.8}
\definecolor{numbercolor}{rgb}{0.5,0.5,0.5}
\definecolor{stringcolor}{rgb}{0.58,0,0.82}
\lstset{%
    language=Verilog,                        % closest to BSV
    backgroundcolor=\color{white},           % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
    basicstyle=\ttfamily\bfseries,              % the size of the fonts that are used for the code
    belowskip=0.5\baselineskip,            % from: http://tex.stackexchange.com/questions/118730/avoid-empty-vert-space-after-lstlisting
    breakatwhitespace=false,                 % sets if automatic breaks should only happen at whitespace
    breaklines=true,                         % sets automatic line breaking
    captionpos=b,                            % sets the caption-position to bottom
    commentstyle=\color{commentcolor},       % comment style
    deletekeywords={...},                    % if you want to delete keywords from the given language
    escapeinside={\%*}{*)},                  % if you want to add LaTeX within your code
    extendedchars=true,                      % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
    frame=single,                            % adds a frame around the code
    %frame=none,                              % doesn't add a frame around the code
    keepspaces=true,                         % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
    %columns=fixed,                           %
    columns=flexible,                        %
    keywordstyle=\color{keywordcolor},       % keyword style
    morekeywords={%
        call,%Called method
        def,%Defined method
        inverted,%Inverted interface
        type,typedef,valueOf,                                    % Type related keywords
        method,endmethod,action,endaction,                  % Methods and actions
        Action,ActionValue,interface,endinterface,          % Interfaces
        Vector,replicate,replicateM,                        % Vector stuff
        Bit,Int,UIng,Reg,Integer,let,tagged,union,struct,   % Basic types
        TAdd,TMul,TDiv,                                     % Type operations
        rule,endrule,return,                                % Rules keywords
        pack,unpack,zeroExtend,signExtend,                  % Common bit functions
        case,matches,endcase                                % Case statements
        synthesize,True,False,Empty,*,...},                 % Etc.
    numbers=left,                            % where to put the line-numbers; possible values are (none, left, right)
    numbersep=5pt,                           % how far the line-numbers are from the code
    numberstyle=\tiny\color{numbercolor},    % the style that is used for the line-numbers
    rulecolor=\color{black},                 % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
    showspaces=false,                        % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
    showstringspaces=false,                  % underline spaces within strings only
    showtabs=false,                          % show tabs within strings adding particular underscores
    stepnumber=1,                            % the step between two line-numbers. If it's 1, each line will be numbered
    stringstyle=\color{stringcolor},         % string literal style
    tabsize=2,                               % sets default tabsize to 2 spaces
    title=\lstname                           % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\newcommand{\mycomment}[1]{\emph{\textcolor{red}{[#1]}}}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\inst}[1]{\textsf{#1}}

\begin{document}

\title{RiscyOO Design Document}
\author{Sizhuo Zhang \\ szzhang@csail.mit.edu \\ MIT CSAIL}
\date{}
\maketitle

\section{Overview}


\section{Processor Core}

Figure~\ref{fig:core} shows the overall structure of the processor core.
Modules are represented by boxes.
The main processor pipeline is the following:
\begin{itemize}
    \item Fetch pipeline $\rightarrow$ Rename stage $\rightarrow$ ROB and all execution pipelines (ALU/Branch, FPU/Int-Mul/Int-Div, and Mem) $\rightarrow$ Commit stage.
\end{itemize}
The rename stage divides the processor core into the front-end and the back-end.
The front-end, i.e., the fetch pipeline, is an in-order pipeline, while out-of-order execution happens all in the back-end.

An instruction is fetched and decoded in the fetch pipeline.
The rename stage performs register renaming and enters the instruction int ROB and one of the execution pipelines.
When the instruction finishes execution and leaves the execution pipeline, it notifies the ROB that it is executed.
Finally the commit stage commits instructions from ROB in order.

The processor core is also superscalar.
The fetch pipeline, rename stage and commit stage can all handle multiple instructions in one cycle.
The size of superscalarity is represented by numeric type \code{SupSize} in the source code and in the rest of this document.
The core also has multiple execution pipelines.
The numbers of ALU/Branch (abbreviated as ALU in the following) execution pipelines and FPU/Int-Mul/Int-Div execution pipelines (abbreviated as FPU in the following) are parametrized.
However, there can only be one memory execution pipeline

\begin{figure}
    \centering
    \includegraphics[width=\columnwidth]{fig/core_crop.pdf}
    \caption{Overall structure of the processor core}\label{fig:core}
\end{figure}

\noindent\textbf{Scheduling Convention:}
Since there are many modules in the core, assigning conflict matrices to different module interfaces to maximize the concurrency of rules can be difficult.
To simplify the problem, we following the convention of \emph{reverse pipeline ordering} in assigning conflict matrices.
That is, rules representing later stages in the processor pipeline (e.g., commit) are ordered before rules representing earlier stages (e.g., rename), and thus, interface methods called in later stages are ordered before methods called in earlier stages.

\noindent\textbf{System Instructions:}
Some instructions can change the context of the processor and are difficult to be executed out of order or concurrently with other instructions.
These instructions are called \emph{system instructions}, and include the following instructions:
\begin{itemize}
    \item \inst{ECALL} which makes a system call,
    \item \inst{EBREAK} which traps for debugger,
    \item \inst{SRET} and \inst{MRET} which return from trap handling,
    \item \inst{SFENCE.VMA} which flushes the TLBs, and
    \item \inst{FENCE.I} which is used for self-modifying code.
\end{itemize}
System instructions are executed in a blocking way, i.e., the instruction will be the only instruction in the ROB.

\noindent\textbf{Organization:}
In the rest of this section, we first introduce the general mechanism to control speculation in the back-end (Section~\ref{sec:specupdate}), and then describe each modules and top-level rules.

\input{kill_scheme}

\input{sb_aggr}

\input{rf_sbcons}

\input{rob}

\section{Uncore}

\end{document}